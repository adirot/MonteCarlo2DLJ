classdef MC2DLJoutput
   properties
      simulationParam = struct;
      currentmaxdr,...
          moveCount,currentCoords,currentDists,currentU,currentPressure,...
          currentStep,...
          fileName,data,L,indIndata;
   end
    methods
        
        function obj = MC2DLJoutput(N,T,rho,initialmaxdr,...
                initialConfig,rCutoff,r)
            
            % constructors for MC2DLJoutput. usage options:
            % 1. create new simulation 
            
            switch nargin 
                case 1
                    
            
            obj.simulationParam.N = N;
            obj.simulationParam.T = T;
            obj.simulationParam.rho = rho;
            obj.simulationParam.L = sqrt(N/rho);
            obj.simulationParam.initialmaxdr = initialmaxdr;
            obj.currentmaxdr = initialmaxdr;
            obj.simulationParam.initialConfig = initialConfig;
            obj.simulationParam.rCutoff = rCutoff;
            obj.simulationParam.r = r;
            obj.moveCount = 0;
            obj.indIndata = 0;
            
            obj.fileName = ['N' num2str(N) 'T' my_num2str(T)...
                    'rho' my_num2str(rho) 'initialmaxdr'...
                    my_num2str(initialmaxdr) 'initialconfig_'...
                    initialConfig 'rCutoff' my_num2str(rCutoff) 'date'...
                    nowdatetimestr()];
                
            allCoords = zeros(2,N,2);
            allDists = zeros(N,N,2);
            [allDists(:,:,1),allCoords(:,:,1)] = ...
                createInitialConfig(obj.simulationParam.L,N,r,initialConfig);
            d = reshape(allDists,1,[]);
            d = nonzeros(d); % make d a row vector
            allU = pairU(d,rCutoff);
            clear d;
            stepInd = 0;
            
            save(obj.fileName, 'allDists','allCoords','allU','stepInd',...
                'simulationParam','-v7.3');
            obj.data = matfile(obj.fileName);
            obj.data = matfile(obj.fileName,'Writable',true);
            
            obj.currentCoords = allCoords;
            obj.currentDists = allDists;
            obj.currentU = allU;
            obj.currentStep = stepInd;
            obj.indIndata = 1;
            clear allDists allCoords allU stepInd;
            
        end
        
        function obj = MonteCarlo(obj,Nsteps,saveEvery)
            
            stepCount = 0;
            while(stepCount < Nsteps)
                [finalU,finalConfiguration,finalDistances,currentmoveCount] = ...
                    MonteCarlo2DLJHeart(obj.simulationParam.N,...
                    obj.simulationParam.T,obj.simulationParam.rho,...
                    obj.simulationParam.N*saveEvery...
                    ,obj.currentmaxdr,obj.currentCoords,...
                    obj.simulationParam.rCutoff...
                    ,obj.currentDists,obj.currentU);
                
                stepCount = stepCount + obj.simulationParam.N*saveEvery;
                obj.currentStep = obj.currentStep...
                    + obj.simulationParam.N*saveEvery;
                obj.moveCount = obj.moveCount + currentmoveCount;
                obj.currentU = finalU;
                obj.currentCoords = finalConfiguration;
                obj.currentDists = finalDistances;
                
                obj = obj.addStep2data(obj.currentStep,finalConfiguration,...
                    finalDistances,finalU);
                
                clear finalU finalConfiguration finalDistances...
                    currentmoveCount
            end
        end
        
        function obj = addStep2data(obj,newInd,newCoords,newDists,newU)
            
            obj.data.stepInd(1,obj.indIndata+1) = newInd;
            s = zeros(2,obj.N,2);
            s(:,:,1) = newCoords(:,:,1);
            obj.data.allCoords(:,:,obj.indIndata+1) = s(:,:,1);
            s = zeros(obj.N,obj.N,2);
            s(:,:,1) = newDists(:,:,1);
            obj.data.allDists(:,:,obj.indIndata+1) = s(:,:,1);
            clear s;
            obj.data.allU(1,obj.indIndata+1) = newU;
            obj.indIndata = obj.indIndata + 1;
            
        end
        
       function showStep(obj,step)
           
          if isnumeric(step)
                  ind = find(obj.data.stepInd == step);
          
                  if isempty(ind) %find the closest index saved
                      [~,ind] = min(abs(obj.data.stepInd - step));
                      step = obj.data.stepInd(1,ind);
                  end
          else
              
              switch step
                  case 'first'
                      ind = 1;
                      step = 0;
                  case 'mid'
                     
                      ind = ceil(obj.indIndata/2);
                      step = obj.data.stepInd(1,ind);
                  case 'last'
                      ind  = obj.indIndata;
                      step = obj.data.stepInd(1,ind);
              end
              
          end 
          
          plotParticles(obj.data.allCoords(:,:,ind),obj.L,obj.r);
          title(['snapshot of step: ' num2str(step)]);
       end
       
    end
end


function [dist,particlesPosition] = ...
            createInitialConfig(L,N,r,initialConfig)

        possibleInitialConfigs = {'random','hex'};
        initialConfigInd = strcmp(initialConfig,possibleInitialConfigs);
        % check if input is valid:
        if sum(initialConfigInd) ~= 1
            error(['choose one of the initial configurations: '...
                my_cell2str(possibleInitialConfigs)]);
        else
            switch find(initialConfigInd)
                case 1 % random initial configuration
                    [dist,particlesPosition] = randomStart(L,N,r);
                case 2 % hexagonal initial configuration
                    [dist,particlesPosition] = hcp(L,N,r);
            end
        end
    end

        function [dist,particlesPosition] = randomStart(L,N,r)
                % randomize first particle possition in the box 
                % [-L/2,L/2] x [-L/2,L/2]
                particlesPosition(1,1) = L*rand - (L/2);
                particlesPosition(2,1) = L*rand - (L/2);
                dist = zeros(N);

                for j = 2:N
                    
                      % choose random possition
                      particlesPosition(1,j) = L*rand - (L/2);
                      particlesPosition(2,j) = L*rand - (L/2);

                      % calculate PBC distances
                      xj = particlesPosition(1,j);
                      yj = particlesPosition(2,j);
                      dist(j,1:j) = distPBC(xj,yj,particlesPosition,L);

                      % check for piriodic boundary condition overlaps,
                      % randomize new possition if overlaps are found.
                      overlapPBC = sum(dist(j,1:(j-1)) < 2*r) > 0;
                      countTry = 0;
                      while overlapPBC
                              particlesPosition(1,j) = L*rand - (L/2);
                              particlesPosition(2,j) = L*rand - (L/2);

                              % calculate PBC distances
                              xj = particlesPosition(1,j);
                              yj = particlesPosition(2,j);
                              dist(j,1:j) = distPBC(xj,yj,particlesPosition,L);

                              overlapPBC = sum(dist(j,1:(j-1)) < 2*r) > 0;
                              countTry = countTry + 1;
                              if countTry > 1000
                                  error(['it is difficult to generate a'...
                                      'random distribution with a density '...
                                      'of ' num2str(N/L^2) '. try a lower '...
                                      'density, or a hexagonal initial'...
                                      ' configuration.']);
                              end
                      end

                end

        end
   
        function [dist,particlesPosition] = hcp(L,N,r)
    
                % Make sure N is a perfect square
                intRoot = floor(sqrt(N));
                if (sqrt(N) - intRoot) > 1e-7
                    % Display an error message
                    disp('Number of particles should be a perfect square');
                    particlesPosition = [];
                    return
                end

                % Calculate the seperation length between particles centers
                sepDist = L/sqrt(N);
                
                % Make sure the density is not too high
                if sepDist < 2*r
                    % Display an error message
                    disp('density is too high');
                    particlesPosition = [];
                    return
                end

                % Find the box size
                Lx = sepDist * sqrt(N);

                % Create a vector of linearly spaced points along the
                % x-direction
                xPos = linspace(sepDist/2, Lx-sepDist/2, sqrt(N));
                % And find the corresponsing y-direction increments
                yPos = (sqrt(3)/2)*xPos;

                % Create a matrix with all combinations of x and y
                [X,Y] = meshgrid(xPos,yPos);
                % Shift coordinates to the be at the center of each
                % particle
                X(1:2:end,:) = X(1:2:end,:) + sepDist/2;

                % Reshape the matrix to be 1D in X and 1D in Y
                % (numel returns the number of elements in a given array)
                particlesPosition =...
                    [reshape(X,1,numel(X));reshape(Y,1,numel(Y))];
                
                % make the board in: [-L/2 L/2]x[-L/2 L/2]
                particlesPosition = particlesPosition - L/2;
                
                        % calculate all pair distances
                dist = zeros(N);
                for par = 1:N

                    x = particlesPosition(1,par);
                    y = particlesPosition(2,par);
                    dist((par+1):N,par) = ...
                        distPBC(x,y,particlesPosition(:,(par+1):N));
                end
                
        end
